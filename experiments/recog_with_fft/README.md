# Recognition with Fast Fourier Transformation <br> v01-exp-stft_params
`NOTE: This README and the code are updated synchronously.`

The purpose of this experiment on `prot-fin v0.1`  is to figure out which parameter values are the best for the STFT.<br>
Here are gonna be tested:
 - Window Size
 - Overlap between Windows
 - Number of maximum selected peaks per Window

---

## Usage
```sh
cd methods
bash slurm.sh ../../../materials/protein.fa ../../../materials/mapmanreferencebins.results.txt
python3 stft_param_exp.py > ../results/stft_param_exp.summary.csv

# optional, view results
column -t -s "," ../results/stft_param_exp.summary.csv | less
```

The parameters are passed by environment variables to `protfin.py`, like this (with the default values):
```sh
WINDOW_SIZE=30 OVERLAP=15 N_PEAKS=0 WINDOW_TYPE=boxcar python3 protfin.py ...
```
Keep in mind that recognition with different parameters only works if the passed database has been created with them.<br>
Just inspect the `slurm.sh` to see the workflow.

## Methods (`methods/*`)
<ul>
    <li>
        <details>
            <summary><code>protfin.py</code> - The tool that is going to be developed</summary>
            <table>
                <th>method</th><th>steps</th>
                <tr>
                    <td>actions.algorithm.kidera:<br><code>get_aa_vector(seq, factor, normalize, file)</code></td>
                    <td>
                        <ul><li>defaults: <code>normalize=True</code>, <code>file="../../../materials/Amino_Acid_Kidera_Factors.csv"</code></li></ul>
                        <ol type="1">
                            <li>read kidera factor values for all amino acids from <code>file</code></li>
                            <li>normalize values by adding the global table mean if <code>normalize</code> is <code>True</code></li>
                            <li>extend value table with columns for symbols representing multiple amino acids, by forming the mean of the corresponding amino acids' vectors</li>
                            <li>extend value table with columns for non-valued amino acids 'O' and 'U', by treating their value as zero</li>
                        </ol>
                    </td>
                </tr>
                <tr>
                    <td>actions.algorithm.constellation:<br><code>create_constellation(aa_vec, window_size, n_peaks, window, **kwargs)</code></td>
                    <td>
                        <ul><li>defaults: <code>n_peaks=0</code>, <code>window="boxcar"</code>, <code>overlap@kwargs=window_size//2</code></li></ul>
                        <ol type="1">
                            <li>Initialize values: equalize <code>window_size</code> to <code>aa_vec</code> if it is greater than the vector size, also set <code>overlap=window_size-1</code> if it is bigger than window size</li>
                            <li>Do a STFT on <code>aa_vec</code> with the given parameters</li>
                            <li>for each STF-transformed window, get the n peaks most prominent peaks as set by <code>n_peaks</code> or select all if <code>n_peaks=0</code></li>
                            <li>for each selected peak in a window, append its frequency and window index as tuple to the constellation map, as these values are necessary for hashing</li>
                        </ol>
                    </td>
                </tr>
                <tr>
                    <td>actions.algorithm.hash_gen:<br><code>create_hashes(constellation_map, prot_id)</code></td>
                    <td>
                        <ol type="1">
                            <li>
                                for each index-value-pair in the map create combinatorial hashes (anker points) with all upcoming of the map if these correspond to one in the next 2<sup>12</sup> amino acids:<br>
                                as frequencies use a max. of 10 bits each, the hashes are generated by combining them into a 32-bit int like: <br>
                                <code>(index_diff)-(freq_of_other_pair)-(frequency)</code>
                            </li>
                            <li>save index and protein id for each hash</li>
                        </ol>
                    </td>
                </tr>
                <tr>
                    <td>actions.find_matches:<br><code>score_prots(hashes, database, protein_index_map)</code></td>
                    <td>
                        <ol type="1">
                            <li>for each hash, collect for each protein its offsets to its occurences in the protein sequence</li>
                            <li>for each protein, calculate its Jaccard Similarity Index (JSI) and group the occurences of the hashes/ankerpoints by their offsets</li>
                            <li>the size of the biggest group and the JSI form the score for a protein, as it is the best fitting constellation of the hashes</li>
                            <li>return the list of scores sorted in descending order by the JSI on first level and by score on the second</li>
                        </ol>
                    </td>
                </tr>
                <tr>
                    <td>actions.create_db:<br><code>create_db(prot_file, db_out, lookup_out)</code></td>
                    <td>
                        <ol type="1">
                            <li>create a database for all proteins in the file by joining the results of <code>create_hashes</code> and write it to <code>db_out</code></li>
                            <li>create a protein-index-map as well to get to the description and hash count for each protein and write it to <code>lookup_out</code></li>
                        </ol>
                    </td>
                </tr>
                <tr>
                    <td>actions.find_matches:<br><code>find_matches(fasta_file)</code></td>
                    <td>
                        <ol type="1">
                            <li>for each protein in the file, find all match(es), using the databases from <code>db_in</code> and <code>lookup_in</code>, and print only the matches with the best score to stdout, as there are currently multiple of them</li>
                        </ol>
                    </td>
                </tr>
            </table>
            <h3>Convenience</h3>
            <code>actions.algorithm.hashes_from_seq(seq, prot_id)</code>
            <ul>
                <li>just the workflow <code>seq_to_vectors</code> $\rightarrow$ <code>create_constellation</code> $\rightarrow$ <code>create_hashes</code></li>
                <li>it accepts environment variables to set STFT parameters, these are: <code>WINDOW_SIZE</code>, <code>WINDOW_TYPE</code>, <code>OVERLAP</code>, <code>N_PEAKS</code></li>
            </ul>
            <code>tools.Fasta(fasta_file)</code>
            <ul>
                <li>a class to iterate easily through the fasta file's contents, adding also a progress bar to indicate processed proteins</li>
                <li>currently not validating the file</li>
            </ul>
            <code>tools.count_appearances_in_file(pattern, file)</code>
            <ul>
                <li>used to count fastly e.g. the number of proteins in a file, which is necessary to create an appropriate progress bar</li>
            </ul>
        </details>
    </li>
    <li>
        <details>
            <summary><code>evaluation.py</code> - Test prot-fin with training data and evaluate the results</summary>
            <table>
                <th>method</th><th>steps</th>
                <tr>
                    <td><code>evaluate_protfin(protfin_out_file)</code></td>
                    <td>
                        <ol type="1">
                            <li>for each output in <code>protfin_out_file</code>, extract the matches' data and count them</li>
                            <li>collect the input specific data from below the output</li>
                            <li>store everything into a dataframe and write it as csv to stdout</li>
                        </ol>
                    </td>
                </tr>
                <tr>
                    <td><code>select_samples(mapman, protein_file, samples_per_family)</code></td>
                    <td>
                        <ol type="1">
                            <li>identify the protein families in <code>mapman</code> file</li>
                            <li>for each family, select randomly <code>samples_per_family</code> proteins</li>
                            <li>find the selected proteins in <code>protein_file</code> and write them as new FASTA formatted output to stdout</li>
                        </ol>
                    </td>
                </tr>
            </table>
        </details>
    </li>
    <li><code>slurm.sh</code> - A script to start jobs with <code>sbatch</code> for each parameter configuration to get the match summaries</li>
    <li><code>stft_param_exp.py</code> - A script to summarize the generated summaries from jobs of <code>slurm.sh</code></li>
</ul>

### Unit Tests
To run the unit tests, just execute the following:
```bash
cd methods
TQDM_DISABLE=1 python3 test.py
```

---
## Results (`results/*`)
|                          file                            |     content
|----------------------------------------------------------|------------------
|[test_selection.summary.csv](./results/test_selection.summary.csv)|a summary of the found matches for 217 protein sequences (7 per family)
|[stft_param_exp.summary.csv](./results/stft_param_exp.summary.csv)|a summary of all summaries of matches for the different parameters

### Reproduce
In this repository, `protein.fa` is used to generate the database. You can extract the file from [this archive](https://github.com/usadellab/prot-fin/raw/5be77c4247327e3958c89200c03a938ec4734834/material/Mapman_reference_DB_202310.tar.bz2). The archive also includes `mapmanreferencebins.results.txt` which maps the proteins to their families.

The used table of Kidera factors is located in [../../materials/Amino_Acid_Kidera_Factors.csv](../../materials/Amino_Acid_Kidera_Factors.csv) and was generated by [this R-script](https://github.com/usadellab/prot-fin/blob/5be77c4247327e3958c89200c03a938ec4734834/methods/Amino_Acid_Kidera_Factors.R). (Read the [root-README](../../README.md) for more details).

[test_selection.summary.csv](./results/test_selection.summary.csv):
```sh
cd methods
materials=../../../materials
python3 protfin.py create-db $materials/protein.fa
python3 evaluation.py select-samples $materials/mapmanreferencebins.results.txt $materials/protein.fa -s 7 > ../results/_test_selection.fa
python3 protfin.py find-matches ../results/_test_selection.fa > ../results/_test_selection.matches
python3 evaluation.py eval ../results/_test_selection.matches > ../results/test_selection.summary.csv
```

[stft_param_exp.summary.csv](./results/stft_param_exp.summary.csv):
```sh
cd methods
bash slurm.sh ../../../materials/protein.fa ../../../materials/mapmanreferencebins.results.txt
python3 stft_param_exp.py > ../results/stft_param_exp.summary.csv
```

---
## Discussion/Brainstorming
The result is interesting. There are some configurations with a high recognition potential.
Following interpretions:
 - accuracy increases by the overlap 
 - small window sizes are very good in recognition (what happens here?)
 - the number of selected peaks doesn't seem to matter (also, why?)

Some ideas for future development:
 - add appropriate testing
 - analyze the identifying hashes for the best config (10, 9, 0) to find out why they are that unique (Maybe they are just unique, as the probability of duplicates between different proteins sinks for such a small window, as the fft can't find many peaks)
 - inspect the other matches on proteins of same family (may be a not as good result as it is now)

---
## Environment
<ul>
    <li><b>Personal</b><br>
        System: <code>Ubuntu 20.04.6 LTS</code>
        Shell: <code>zsh 5.8</code><br>
        <br>
        <table>
            <th>dependency</th><th>version</th>
            <tr><td>python3</td><td>3.8.10</td></tr>
            <tr><td>scipy</td><td>1.10.1</td></tr>
            <tr><td>numpy</td><td>1.23.0</td></tr>
            <tr><td>pandas</td><td>2.0.1</td></tr>
            <tr><td>tqdm</td><td>4.66.2</td></tr>
        </table>
    </li>
    <li><b>Slurm</b><br>
        System: <code>Ubuntu 20.04.4 LTS</code>
        Shell: <code>zsh 5.8.1</code><br>
        <br>
        <table>
            <th>dependency</th><th>version</th>
            <tr><td>slurm-wlm</td><td>21.08.5</td></tr>
            <tr><td>python3</td><td>3.10.12</td></tr>
            <tr><td>scipy</td><td>1.11.4</td></tr>
            <tr><td>numpy</td><td>1.26.2</td></tr>
            <tr><td>pandas</td><td>2.1.3</td></tr>
            <tr><td>tqdm</td><td>4.66.2</td></tr>
        </table>
    </li>
</ul>
