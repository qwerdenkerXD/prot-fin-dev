# Recognition with Fast Fourier Transformation
`NOTE: This README and the code are updated synchronously.`

The concept of this experiment is to generate a vector of values from an amino acid sequence, using one factor of [the table of Kidera factors](../../materials/Amino_Acid_Kidera_Factors.csv), for now. These factors represent the 10 most identifying features of amino acids.<br>
With doing a Short Time Fourier Transformation (STFT) on the created vector, it is now possible to find structual features in the sequence to create a specific constellation of them.

Now, instead of looking on text-based likelihood, the goal is to identify a protein by its own sequence from this constellation, so it needs to be unique like a fingerprint, but still similar to related sequences of the same family and less similar to others.

---

## Usage
1. go to `./methods`
2. create a database of reference proteins: `python3 protfin.py create-db <ref-fasta>`
3. find best scored matches for protein sequence samples: `python3 protfin.py find-match <samples-fasta>`

In this repository, `protein.fa` is used to generate the database.<br>
If you want to reproduce the files in `results/`, extract the file from [this archive](https://github.com/usadellab/prot-fin/raw/5be77c4247327e3958c89200c03a938ec4734834/material/Mapman_reference_DB_202310.tar.bz2), use [./materials/protein_test.fa](./materials/protein_test.fa) as parameter for `find-match` and pipe the matches with Jaccard Similarity score of 1.0 into `results/initial_test.out`, like this:<br>
`python3 protfin.py find-match ../materials/protein_test.fa | grep -P "1\.0" > ../results/initial_test.out`

The used table of Kidera factors is located in [../../materials/Amino_Acid_Kidera_Factors.csv](../../materials/Amino_Acid_Kidera_Factors.csv) and was generated by [this R-script](https://github.com/usadellab/prot-fin/blob/5be77c4247327e3958c89200c03a938ec4734834/methods/Amino_Acid_Kidera_Factors.R). (Read the [root-README](../../README.md) for more details)

## Methods (`methods/*`)
<table>
    <th>method</th><th>steps</th>
    <tr>
        <td><code>get_aa_vector(seq, factor, normalize, file)</code></td>
        <td>
            <ul><li>defaults: <code>normalize=True</code>, <code>file="../../../materials/Amino_Acid_Kidera_Factors.csv"</code></li></ul>
            <ol>
                <li>read kidera factor values for all amino acids from <code>file</code></li>
                <li>normalize values by global table mean if <code>normalize</code> is <code>True</code></li>
                <li>extend value table with columns for symbols representing multiple amino acids, by forming the mean of the corresponding amino acids' vectors</li>
                <li>extend value table with columns for non-valued amino acids 'O' and 'U', by treating their value as zero</li>
            </ol>
        </td>
    </tr>
    <tr>
        <td><code>create_constellation(aa_vec, window_size, n_peaks, window, **kwargs)</code></td>
        <td>
            <ul><li>defaults: <code>n_peaks=0</code>, <code>window="boxcar"</code>, <code>overlap@kwargs=window_size//2</code></li></ul>
            <ol>
                <li>Initialize values: equalize <code>window_size</code> to <code>aa_vec</code> if it is greater than the vector size, also set <code>overlap=window_size-1</code> if it is bigger than window size</li>
                <li>Do a STFT on <code>aa_vec</code> with the given parameters</li>
                <li>for each STF-transformed window, get the n peaks most prominent peaks as set by <code>n_peaks</code> or select all if <code>n_peaks=0</code></li>
                <li>for each selected peak in a window, append its frequency and window index as tuple to the constellation map, as these values are necessary for hashing
            </ol>
        </td>
    </tr>
    <tr>
        <td><code>create_hashes(constellation_map, prot_id)</code></td>
        <td>
            <ol>
                <li>
                    for each index-value-pair in the map create combinatorial hashes (anker points) with all upcoming of the map if these correspond to one in the next 2<sup>12</sup> amino acids:<br>
                    as frequencies use a max. of 10 bits each, the hashes are generated by combining them into a 32-bit int like: <br>
                    <code>(index-diff)-(freq_of_other_pair)-(frequency)</code>
                </li>
                <li>save index and protein id for each hash</li>
            </ol>
        </td>
    </tr>
    <tr>
        <td><code>score_prots(hashes, database, protein_index_map)</code></td>
        <td>
            <ol>
                <li>for each hash, collect for each protein its offsets to its occurences in the protein sequence</li>
                <li>for each protein, calculate its Jaccard Similarity Index (JSI) and group the occurences of the hashes/ankerpoints by their offsets</li>
                <li>the size of the biggest group and the JSI form the score for a protein, as it is the best fitting constellation of the hashes</li>
                <li>return the list of scores sorted in descending order by the JSI on first level and by score on the second</li>
            </ol>
        </td>
    </tr>
    <tr>
        <td><code>create_db(prot_file, db_out, lookup_out)</code></td>
        <td>
            <ol>
                <li>create a database for all proteins in the file by joining the results of <code>create_hashes</code> and write it to <code>db_out</code></li>
                <li>create a protein-index-map as well to get to the description and hash count for each protein and write it to <code>lookup_out</code></li>
            </ol>
        </td>
    </tr>
    <tr>
        <td><code>find_match(fasta_file)</code></td>
        <td>for each protein in the file, find all match(es), using the databases from <code>db_in</code> and <code>lookup_in</code>, and print them to stdout</td>
    </tr>
</table>

### Convenience
`hashes_from_seq(seq, prot_id)`
 - just the workflow `seq_to_vectors` $\rightarrow$ `create_constellation` $\rightarrow$ `create_hashes`

`class Fasta(fasta_file)`
 - a class to iterate easily through the fasta file's contents, adding also a progress bar to indicate processed proteins
 - currently not validating the file

---
## Results (`results/*`)
|                    file                      |     content
|----------------------------------------------|------------------
|[initial_test.out](./results/initial_test.out)|just a test of the basic functionality of the recognition<br>input was the original protein sequence of A0A1D8EJF9<br>around 900 other proteins share its score and form the first place.

---
## Discussion/Brainstorming
The initial test shows that it is really fast and does not need much storage space. But its output implies that the constellation of structural features is not identical enough.<br>

Some ideas for future development:
 - add appropriate testing
 - find ways to create more hashes or to increase their quality
   - find the best combination of parameters for the STFT $\rightarrow$ maybe more hashes
   - don't just use the peaks only (`create_constellations`) $\rightarrow$ maybe more hashes
   - include the frequencies' amplitudes of the STFT in the hashes $\rightarrow$ maybe better quality

---
## Environment

System: `Ubuntu 20.04.6 LTS`
Shell: `zsh 5.8`

| dependency | version |
|------------|---------|
|   python3  | 3.8.10  |
|    scipy   | 1.10.1  |
|    numpy   | 1.23.0  |
|   pandas   |  2.0.1  |
|    tqdm    | 4.66.2  |
