# Recognition with Fast Fourier Transformation<br>v0.2-exp-peak_selection
`NOTE: This README and the code are updated synchronously.`

This experiment is to analyze the way of peak selection in STFT returned spectrum. Currently, the `find_peaks` function from `scipy.signal` is used.<br>
In the case of music this makes sense, but in case of proteins there is no reason to ignore high weighted frequencies even if they aren't local maxima. Therefore, selecting the frequencies by sorting their amplitudes descending and selecting the first ones is the alternative that is to be viewed here.

---

## Usage
1. go to `./methods`
2. create a database of reference proteins: `python3 protfin.py create-db <ref-fasta>`
3. find best scored matches for protein sequence samples: `python3 protfin.py find-matches <samples-fasta>`

### Tools
```sh
cd methods

# select sample proteins from different mapman bins
python3 evaluation.py select-samples mapmanreferencebins.results.txt protein.fa > samples.fa

# summarize output generated by: python3 protfin.py find-matches ... > protfin_out.csv
python3 evaluation.py eval protfin_out.csv > protfin_out.summary.csv

# summarize evaluation summaries
python3 summary.py *.summary.csv

# extend the protfin output with two columns for the match related mapman bins
awk -v protfin_out=protfin_out.csv -f extend_protfin_out.awk mapmanreferencebins.results.txt > protfin_out.extended.csv

# generate a plot for counts of calculated hashes
TITLE="Distribution of sequences' hash counts" X_LABEL="Hash counts" \
Rscript raincloud_plot.R normal <(python3 evaluation.py print-hash-counts database.pickle) plot.png
```

### Unit Testing
To run the unit tests, just run the following:
```sh
cd methods
TQDM_DISABLE=1 python3 test.py
```


## Methods (`methods/*`)
<ul>
    <li>
        <details>
            <summary><code>protfin.py</code> - The tool that is going to be developed</summary>
            <table>
                <th>method</th><th>steps</th>
                <tr>
                    <td>actions.algorithm.kidera:<br><code>get_aa_vector(seq, factor, normalize, file)</code></td>
                    <td>
                        <ul><li>defaults: <code>normalize=True</code>, <code>file="../../../materials/Amino_Acid_Kidera_Factors.csv"</code></li></ul>
                        <ol type="1">
                            <li>read kidera factor values for all amino acids from <code>file</code></li>
                            <li>normalize values by adding the global table mean if <code>normalize</code> is <code>True</code></li>
                            <li>extend value table with columns for symbols representing multiple amino acids, by forming the mean of the corresponding amino acids' vectors</li>
                            <li>extend value table with columns for non-valued amino acids 'O' and 'U', by treating their value as zero</li>
                        </ol>
                    </td>
                </tr>
                <tr>
                    <td>actions.algorithm.constellation:<br><code>create_constellation(aa_vec, window_size, n_peaks, window, **kwargs)</code></td>
                    <td>
                        <ul><li>defaults: <code>n_peaks=0</code>, <code>window="boxcar"</code>, <code>overlap@kwargs=window_size//2</code></li></ul>
                        <ol type="1">
                            <li>Initialize values: equalize <code>window_size</code> to <code>aa_vec</code> if it is greater than the vector size, also set <code>overlap=window_size-1</code> if it is bigger than window size</li>
                            <li>Do a STFT on <code>aa_vec</code> with the given parameters</li>
                            <li>for each STF-transformed window, get the n peaks most prominent peaks as set by <code>n_peaks</code> or select all if <code>n_peaks=0</code></li>
                            <li>for each selected peak in a window, append its frequency and window index as tuple to the constellation map, as these values are necessary for hashing</li>
                        </ol>
                    </td>
                </tr>
                <tr>
                    <td>actions.algorithm.hash_gen:<br><code>create_hashes(constellation_map, prot_id)</code></td>
                    <td>
                        <ol type="1">
                            <li>
                                for each index-value-pair in the map create combinatorial hashes (anker points) with all upcoming of the map if these correspond to one in the next 2<sup>12</sup> amino acids:<br>
                                as frequencies use a max. of 10 bits each, the hashes are generated by combining them into a 32-bit int like: <br>
                                <code>(index_diff)-(freq_of_other_pair)-(frequency)</code>
                            </li>
                            <li>save index and protein id for each hash</li>
                        </ol>
                    </td>
                </tr>
                <tr>
                    <td>actions.find_matches:<br><code>score_prots(hashes, database, protein_index_map)</code></td>
                    <td>
                        <ol type="1">
                            <li>for each hash, collect for each protein its offsets to its occurences in the protein sequence</li>
                            <li>for each protein, calculate its Jaccard Similarity Index (JSI) and group the occurences of the hashes/ankerpoints by their offsets</li>
                            <li>the size of the biggest group and the JSI form the score for a protein, as it is the best fitting constellation of the hashes</li>
                            <li>return the scores as Dictionary of protein identifiers pointing to their scores</li>
                        </ol>
                    </td>
                </tr>
                <tr>
                    <td>actions.create_db:<br><code>create_db(prot_file, db_out, lookup_out)</code></td>
                    <td>
                        <ol type="1">
                            <li>create a database for all proteins in the file by joining the results of <code>create_hashes</code> and write it to <code>db_out</code></li>
                            <li>create a protein-index-map as well to get to the description and hash count for each protein and write it to <code>lookup_out</code></li>
                        </ol>
                    </td>
                </tr>
                <tr>
                    <td>actions.find_matches:<br><code>find_matches(fasta_file)</code></td>
                    <td>
                        <ol type="1">
                            <li>for each protein in the file, find all match(es), using the databases from <code>db_in</code> and <code>lookup_in</code>, and print only the matches with the best score to stdout, as there are currently multiple of them. The score consists of the JSI as first level weight and the custom score on second level</li>
                        </ol>
                    </td>
                </tr>
            </table>
            <h3>Convenience</h3>
            <code>actions.algorithm.hashes_from_seq(seq, prot_id)</code>
            <ul>
                <li>just the workflow <code>seq_to_vectors</code> $\rightarrow$ <code>create_constellation</code> $\rightarrow$ <code>create_hashes</code></li>
            </ul>
            <code>tools.Fasta(fasta_file)</code>
            <ul>
                <li>a class to iterate easily through the fasta file's contents, adding also a progress bar to indicate processed proteins</li>
                <li>currently not validating the file</li>
            </ul>
            <code>tools.count_appearances_in_file(pattern, file)</code>
            <ul>
                <li>used to count fastly e.g. the number of proteins in a file, which is necessary to create an appropriate progress bar</li>
            </ul>
            <code>tools.verify_type(val, ty)</code>
            <ul>
                <li>used in unit tests to easily and deeply verify a value's data type</li>
            </ul>
        </details>
    </li>
    <li>
        <details>
            <summary><code>evaluation.py</code> - Test prot-fin with training data and evaluate the results</summary>
            <table>
                <th>method</th><th>steps</th>
                <tr>
                    <td><code>evaluate_protfin(protfin_out_file)</code></td>
                    <td>
                        <ol type="1">
                            <li>for each output in <code>protfin_out_file</code>, extract the matches' data and count them</li>
                            <li>collect the input specific data from below the output</li>
                            <li>store everything into a dataframe and write it as csv to stdout</li>
                        </ol>
                    </td>
                </tr>
                <tr>
                    <td><code>select_samples(mapman, protein_file, samples_per_family)</code></td>
                    <td>
                        <ol type="1">
                            <li>identify the protein families in <code>mapman</code> file</li>
                            <li>for each family, select randomly <code>samples_per_family</code> proteins</li>
                            <li>find the selected proteins in <code>protein_file</code> and write them as new FASTA formatted output to stdout</li>
                        </ol>
                    </td>
                </tr>
                <tr>
                    <td><code>print_hash_counts(database)</code></td>
                    <td>
                        <ol type="1">
                            <li>Extract the hash counts from the protein lookup in <code>database</code></li>
                            <li>Print the extracted values comma separated to stdout</li>
                        </ol>
                    </td>
                </tr>
            </table>
        </details>
    </li>
    <li><code>extend_protfin_out.awk</code> - A script to extend the protfin output with two columns for the match related mapman bins</li>
    <li><code>raincloud_plot.R</code> - A script to plot groups of values into a raincloud plot</li>
    <li><code>summary.py</code> - A script to summarize the outputs from <code>evaluation.py eval</code></li>
</ul>

### Unit Tests
To run the unit tests, just execute the following:
```bash
cd methods
TQDM_DISABLE=1 python3 test.py
```

---
## Results (`results/*`)
|                          file                                                |     content
|------------------------------------------------------------------------------|------------------
|[test_selection.summary.csv](./results/find_peaks_selection.summary.csv)|the summary of protfin for 217 query sequences
|[find_peaks_selection.summary.csv](./results/find_peaks_selection.summary.csv)|the summary of protfin for 217 query sequences, using `N_PEAKS=5`. It is the same output as in `test_selection.summary.csv` with selecting all peaks.
|[sorted_selection.summary.csv](./results/sorted_selection.summary.csv)|the summary of protfin for 217 query sequences, using `N_PEAKS=5` and peak selection by sorting.
|[summary.csv](./results/summary.csv)|the summary all `*.summary.csv` files. The results of the selection by sorting have a lower average match count, but a higher median.
|[hash_count_dist.png](./results/hash_count_dist.png)|a raincloud plot of the hash counts calculated for the sequences with the different peak selection methods

### Reproduce
In this repository, `protein.fa` is used to generate the database. You can extract the file from [this archive](https://github.com/usadellab/prot-fin/raw/5be77c4247327e3958c89200c03a938ec4734834/material/Mapman_reference_DB_202310.tar.bz2). The archive also includes `mapmanreferencebins.results.txt` which maps the proteins to their families.

The used table of Kidera factors is located in [../../materials/Amino_Acid_Kidera_Factors.csv](../../materials/Amino_Acid_Kidera_Factors.csv) and was generated by [this R-script](https://github.com/usadellab/prot-fin/blob/5be77c4247327e3958c89200c03a938ec4734834/methods/Amino_Acid_Kidera_Factors.R). (Read the [root-README](../../README.md) for more details).

[test_selection.summary.csv](./results/test_selection.summary.csv):
```sh
cd methods
materials=../../../materials
python3 protfin.py create-db $materials/protein.fa
python3 evaluation.py select-samples $materials/mapmanreferencebins.results.txt $materials/protein.fa -s 7 > ../results/_test_selection.fa
python3 protfin.py find-matches ../results/_test_selection.fa > ../results/_test_selection.matches
python3 evaluation.py eval ../results/_test_selection.matches > ../results/test_selection.summary.csv
```

[find_peaks_selection.summary.csv](./results/find_peaks_selection.summary.csv):
```sh
cd methods
materials=../../../materials
N_PEAKS=5 python3 protfin.py create-db $materials/protein.fa -p find_peaks_selection.pickle
python3 evaluation.py select-samples $materials/mapmanreferencebins.results.txt $materials/protein.fa -s 7 > ../results/_test_selection.fa
N_PEAKS=5 python3 protfin.py find-matches ../results/_test_selection.fa -d find_peaks_selection.pickle > ../results/_find_peaks_selection.matches
python3 evaluation.py eval ../results/_find_peaks_selection.matches > ../results/find_peaks_selection.summary.csv
```

[sorted_selection.summary.csv](./results/sorted_selection.summary.csv):
```sh
cd methods
materials=../../../materials
SELECTION=sorted N_PEAKS=5 python3 protfin.py create-db ../../../materials/protein.fa -p sorted_selection.pickle
python3 evaluation.py select-samples $materials/mapmanreferencebins.results.txt $materials/protein.fa -s 7 > ../results/_test_selection.fa
SELECTION=sorted N_PEAKS=5 python3 protfin.py find-matches ../results/_test_selection.fa -d sorted_selection.pickle > ../results/_sorted_selection.matches
python3 evaluation.py eval ../results/_sorted_selection.matches > ../results/sorted_selection.summary.csv
```

[summary.csv](./results/summary.csv):
```sh
cd methods
materials=../../../materials
python3 summarize.py ../results/*.summary.csv > ../results/summary.csv
```

[hash_count_dist.png](./results/hash_count_dist.png):
```sh
cd methods
materials=../../../materials
N_PEAKS=5 python3 protfin.py create-db $materials/protein.fa -p find_peaks_selection.pickle
SELECTION=sorted N_PEAKS=5 python3 protfin.py create-db $materials/protein.fa -p sorted_selection.pickle
TITLE="Distribution of sequences' hash counts" X_LABEL="Hash counts" \
Rscript raincloud_plot.R "find_peaks()" <(python3 evaluation.py print-hash-counts find_peaks_selection.pickle) "sorted()" <(python3 evaluation.py print-hash-counts sorted_selection.pickle) ../results/hash_count_dist.png
```

---
## Discussion/Brainstorming
As of the results summary, it seems that the average number of found matches on first place is a bit better for the sorting way. Maybe there are more matches in the same family.

It would be interesting to know if it has a higher influence if we take more peaks or all, which means that we include all found frequencies, which may lead to very high computation time when calculating the hashes. But the accuracy could be much better.

Some ideas for future development:
 - add appropriate testing
 - play with `N_PEAKS`

---
## Environment

System: `Ubuntu 20.04.6 LTS`
Shell: `zsh 5.8`

| dependency | version |
|------------|---------|
|   python3  | 3.8.10  |
|    scipy   | 1.10.1  |
|    numpy   | 1.23.0  |
|   pandas   |  2.0.1  |
|    tqdm    | 4.66.2  |
|      R     |  3.6.3  |
|   tibble   |  3.2.1  |
|   ggplot2  |  3.5.0  |
|   ggdist   |  3.3.2  |
