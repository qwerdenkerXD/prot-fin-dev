# Recognition with Fast Fourier Transformation
`NOTE: This README and the code are updated synchronously.`

The concept of this experiment is to generate a vector of values from an amino acid sequence, using one factor of [the table of Kidera factors](../../materials/Amino_Acid_Kidera_Factors.csv), for now. These factors represent the 10 most identifying features of amino acids.<br>
With doing a Short Time Fourier Transformation (STFT) on the created vector, it is now possible to find structual features in the sequence to create a specific constellation of them.

Now, instead of looking on text-based likelihood, the goal is to identify a protein by its own sequence from this constellation, so it needs to be unique like a fingerprint, but still similar to related sequences of the same family and less similar to others.

---

## Usage
1. go to `./methods`
2. create a database of reference proteins: `python3 protfin.py create-db <ref-fasta>`
3. find best scored matches for protein sequence samples: `python3 protfin.py find-matches <samples-fasta>`

### Tools
```sh
cd methods

# create a boxplot for protein counts for a hash, grouped by the hash's window distance
python3 evaluation.py plot-prots-per-windist database.pickle plot.png

# select sample proteins from different mapman bins
python3 evaluation.py select-samples mapmanreferencebins.results.txt protein.fa > samples.fa

# summarize output generated by: python3 protfin.py find-matches ... > protfin_out.summary.csv
python3 evaluation.py eval protfin_out.summary.csv

# summarize the *.summary.csv
python3 summary.py *.summary.csv

# extend the protfin output with two columns for the match related mapman bins
awk -v protfin_out=protfin_out.csv -f extend_protfin_out.awk mapmanreferencebins.results.txt > protfin_out.extended.csv 

# create a plot of the extended output file
python3 evaluation.py plot-extended-out protfin_out.extended.csv plot.png

# generate a plot for counts of calculated hashes
TITLE="Distribution of sequences' hash counts" X_LABEL="Hash counts" \
Rscript raincloud_plot.R normal <(python3 evaluation.py print-hash-counts database.pickle) plot.png

# generate a plot for counts of proteins per hash with a log10 transformation
TITLE="Distribution of proteins per hash" X_LABEL="Protein counts" \
Rscript raincloud_plot_log10.R normal <(python3 evaluation.py print-prots-per-hash database.pickle) plot.png
```

### Unit Testing
To run the unit tests, just run the following:
```sh
cd methods
TQDM_DISABLE=1 python3 test.py
```


## Experiments
<ul>
    <li>
        <details>
            <summary><code>v0.1-exp-stft_params</code> - Trying different parameters for the STFT to fit the best: <a href="https://github.com/usadellab/prot-fin/blob/v0.1-exp-stft_params/experiments/recog_with_fft">go to branch</a></summary>
            The creation of the constellation map is based on the STFT.<br>
            To increase the accuracy of the recognition algorithm, it is very important to optimize the parameters to generate the most effective constellation map for a protein.
            <br><br>
            Therefore, window size, overlap and number of selected peaks are passed to <code>prot-fin</code>.<br>
            As every configuration of parameters needs a custom database, this procedure is done in parallel on a compute cluster.<br>
            The results of each recognition process are summarized in <a href="https://github.com/usadellab/prot-fin/blob/v0.1-exp-stft_params/experiments/recog_with_fft/results/stft_param_exp.summary.csv">stft_param_exp.summary.csv</a>.
            <br><br>
            It looks like that the maximum overlap (so hop size of 1) is the best option for accuracy.<br>
            Currently, for window size and selected peaks are further analyses necessary.
        </details>
    </li>
    <li>
        <details>
            <summary><code>v0.2-exp-hash_analysises</code> - Analyzing the generated hashes: <a href="https://github.com/usadellab/prot-fin/blob/v0.2-exp-hash_analysises/experiments/recog_with_fft">go to branch</a></summary>
            The recognition of proteins in protfin is based on hashes.<br>
            To increase the accuracy of the recognition algorithm, a high quantity and quality of hashes is of interest.<br>
            To understand how to improve both efficiently, is the purpose of this experiment.
            <br><br>
            Therefore, hash counts and their components will be analyzed.
            <br><br>
            Currently, there are very many unused hashes that are just ignored, as <a href="https://github.com/usadellab/prot-fin/blob/v0.2-exp-hash_analysises/experiments/recog_with_fft/results/potential_hashes.png">potential_hashes.png</a> implies.
        </details>
    </li>
    <li>
        <details>
            <summary><code>v0.2-exp-hashed_amplitudes</code> - Analyzing the influence of STFT amplitudes included in hashes: <a href="https://github.com/usadellab/prot-fin/blob/v0.2-exp-hashed_amplitudes/experiments/recog_with_fft">go to branch</a></summary>
            The recognition of proteins in protfin is based on hashes.<br>
            Currently, hashes are created of STFT frequency pairs and the distance between them in the constelllation map.<br>
            Including the STFT amplitudes could increase the hashes' quality, as they store more information then.
            <br><br>
            Therefore, the amplitudes will be included in hash generation as the result of the comparisons between the amplitudes of the frequency pairs that are included in a hash.<br>
            So the amplitudes take only a few bits, as the full values may lead to overfitting.
            <br><br>
            Using 1 or 2 bits seems to work good enough, as <a href="https://github.com/usadellab/prot-fin/blob/v0.2-exp-hashed_amplitudes/experiments/recog_with_fft/results/summary.csv">summary.csv</a> implies.<br>
            Currently, only the first rank of matches is analyzed to see if the original match was identified. The other related matches need to be checked on familiarity concerning their mapman bins.
        </details>
    </li>
    <li>
        <details>
            <summary><code>v0.2-exp-peak_selection</code> - Analyzing the peak selection method in STFT: <a href="https://github.com/usadellab/prot-fin/blob/v0.2-exp-peak_selection/experiments/recog_with_fft">go to branch</a></summary>
            To create hashes from a STFT, only a subset of frequencies is selected to be included in the hash generation.<br>
            Currently, the <code>scipy.signal.find_peaks</code> function is used to select the local maxima only. But in case of protein sequences instead of music, this may not be that useful, as the maxima's neighbors could be still relevant for identification of familiar proteins.
            <br><br>
            Therefore, an alternative way of selection is going to be developed. The current approach is to just sort the frequencies by their amplitudes descending and select the first ones.
            <br><br>
            The difference for 5 selected peaks doesn't seem that big, as <a href="https://github.com/usadellab/prot-fin/blob/v0.2-exp-peak_selection/experiments/recog_with_fft/results/summary.csv">summary.csv</a> shows.<br>
            The average match count is lower, but not that much. Further analysises necessary.
        </details>
    </li>
</ul>

## Methods (`methods/*`)
<ul>
    <li>
        <details>
            <summary><code>protfin.py</code> - The tool that is going to be developed</summary>
            <table>
                <th>method</th><th>steps</th>
                <tr>
                    <td>actions.algorithm.kidera:<br><code>get_aa_vector(seq, factor, normalize, file)</code></td>
                    <td>
                        <ul><li>defaults: <code>normalize=True</code>, <code>file="../../../materials/Amino_Acid_Kidera_Factors.csv"</code></li></ul>
                        <ol type="1">
                            <li>read kidera factor values for all amino acids from <code>file</code></li>
                            <li>normalize values by adding the global table mean if <code>normalize</code> is <code>True</code></li>
                            <li>extend value table with columns for symbols representing multiple amino acids, by forming the mean of the corresponding amino acids' vectors</li>
                            <li>extend value table with columns for non-valued amino acids 'O' and 'U', by treating their value as zero</li>
                        </ol>
                    </td>
                </tr>
                <tr>
                    <td>actions.algorithm.constellation:<br><code>create_constellation(aa_vec, window_size, n_peaks, window, **kwargs)</code></td>
                    <td>
                        <ul><li>defaults: <code>n_peaks=0</code>, <code>window="boxcar"</code>, <code>overlap@kwargs=window_size//2</code></li></ul>
                        <ol type="1">
                            <li>Initialize values: equalize <code>window_size</code> to <code>aa_vec</code> if it is greater than the vector size, also set <code>overlap=window_size-1</code> if it is bigger than window size</li>
                            <li>If input sequence is shorter than window size, return empty map</li>
                            <li>Do a STFT on <code>aa_vec</code> with the given parameters</li>
                            <li>for each STF-transformed window, get the n most prominent peaks as set by <code>n_peaks</code> or select all if <code>n_peaks=0</code></li>
                            <li>append all tuples of peak and its amplitude as selected by <code>find_peaks</code> as one whole tuple to the constellation map, so one tuple per window with all its frequencies</li>
                        </ol>
                    </td>
                </tr>
                <tr>
                    <td>actions.algorithm.hash_gen:<br><code>create_hashes(constellation_map, prot_id)</code></td>
                    <td>
                        <ol type="1">
                            <li>
                                for each frequency in each window in the map create combinatorial hashes (anker points) with all upcoming frequencies in the next 2<sup>12</sup> windows:<br>
                                as frequencies use a max. of 5 bits each, the hashes are generated by combining them into a 32-bit int like: <br>
                                <code>(zeros)-(index_diff)-(freq_of_other_pair)-(frequency)</code><br>
                                So currently there are 10 unused bits of zeros that can be assigned in further experiments.
                            </li>
                            <li>save index and protein id for each hash</li>
                        </ol>
                    </td>
                </tr>
                <tr>
                    <td>actions.find_matches:<br><code>score_prots(hashes, database, protein_lookup)</code></td>
                    <td>
                        <ol type="1">
                            <li>for each hash, collect for each protein its offsets to its occurences in the protein sequence</li>
                            <li>for each protein, calculate its Jaccard Similarity Index (JSI)</li>
                            <li>the offset having the most matching occurences and the JSI form the score for a protein, as it is the best fitting constellation of the hashes</li>
                            <li>return the scores as Dictionary of protein identifiers pointing to their scores</li>
                        </ol>
                    </td>
                </tr>
                <tr>
                    <td>actions.create_db:<br><code>create_db(prot_file, db_out)</code></td>
                    <td>
                        <ol type="1">
                            <li>create a database for all proteins in the file by joining the results of <code>create_hashes</code></li>
                            <li>create a protein-lookup as well to get to the hash count for each protein</li>
                            <li>dump both into <code>db_out</code></li>
                        </ol>
                    </td>
                </tr>
                <tr>
                    <td>actions.find_matches:<br><code>find_matches(fasta_file, db_in)</code></td>
                    <td>
                        <ol type="1">
                            <li>for each protein in the file, find all match(es), using the database in <code>db_in</code>, and print them to stdout. The score consists of the custom score multiplied with the JSI</li>
                        </ol>
                    </td>
                </tr>
            </table>
            <h3>Convenience</h3>
            <code>actions.algorithm.hashes_from_seq(seq, prot_id)</code>
            <ul>
                <li>just the workflow <code>seq_to_vectors</code> $\rightarrow$ <code>create_constellation</code> $\rightarrow$ <code>create_hashes</code></li>
            </ul>
            <code>tools.Fasta(fasta_file)</code>
            <ul>
                <li>a class to iterate easily through the fasta file's contents with support of slicing, adding also a progress bar to indicate processed proteins</li>
                <li>currently not validating the file</li>
            </ul>
            <code>tools.count_appearances_in_file(pattern, file)</code>
            <ul>
                <li>used to count fastly e.g. the number of proteins in a file, which is necessary to create an appropriate progress bar</li>
            </ul>
            <code>tools.verify_type(val, ty)</code>
            <ul>
                <li>used in unit tests to easily and deeply verify a value's data type</li>
            </ul>
            <code>tools.divide_evenly(num, n_parts)</code>
            <ul>
                <li>currently used to easily divide <code>num</code> tasks equally among assigned cores</li>
            </ul>
            <code>tools.pd_read_chunkwise(csv_file, chunksize)</code>
            <ul>
                <li>used for chunkwise iteration over the protfin output csv to reduce memory usage</li>
                <li>a returned item stores all matches of one input protein</li>
            </ul>
        </details>
    </li>
    <li>
        <details>
            <summary><code>evaluation.py</code> - Test prot-fin with training data and evaluate the results</summary>
            <table>
                <th>method</th><th>steps</th>
                <tr>
                    <td><code>evaluate_protfin(protfin_out_file)</code></td>
                    <td>
                        <ol type="1">
                            <li>for each output in <code>protfin_out_file</code>, extract the matches' data and count them</li>
                            <li>collect the input specific data from below the output</li>
                            <li>store everything into a dataframe and write it as csv to stdout</li>
                        </ol>
                    </td>
                </tr>
                <tr>
                    <td><code>select_samples(mapman, protein_file, samples_per_family)</code></td>
                    <td>
                        <ol type="1">
                            <li>identify the protein families in <code>mapman</code> file</li>
                            <li>for each family, select randomly <code>samples_per_family</code> proteins</li>
                            <li>find the selected proteins in <code>protein_file</code> and write them as new FASTA formatted output to stdout</li>
                        </ol>
                    </td>
                </tr>
                <tr>
                    <td><code>print_hash_counts(database)</code></td>
                    <td>
                        <ol type="1">
                            <li>Extract the hash counts from the protein lookup in <code>database</code></li>
                            <li>Print the extracted values comma separated to stdout</li>
                        </ol>
                    </td>
                </tr>
                <tr>
                    <td><code>print_prots_per_hash(database)</code></td>
                    <td>
                        <ol type="1">
                            <li>Extract the counts of proteins per hash from the <code>database</code></li>
                            <li>Print the extracted values comma separated to stdout</li>
                        </ol>
                    </td>
                </tr>
                <tr>
                    <td><code>plot_frequencies(prot_file, out_file, cpu_count)</code></td>
                    <td>
                        <ol type="1">
                            <li>Create the constellation maps of all sequences and collect the selected frequencies</li>
                            <li>Plot the frequences' rates and indicate how many sequences share a frequence</li>
                        </ol>
                    </td>
                </tr>
                <tr>
                    <td><code>plot_extended_out(ext_out, plot_out)</code></td>
                    <td>
                        <ol type="1">
                            <li>Iterate through the proteins' matches and plot a box of the scores of each</li>
                            <li>Also add dots for each score of family and non-family matches</li>
                        </ol>
                    </td>
                </tr>
                <tr>
                    <td><code>plot_prots_per_windist(database, out_file)</code></td>
                    <td>
                        <ol type="1">
                            <li>Collect the protein counts per hash, grouped by the hash's window distance</li>
                            <li>Plot boxes per window distance</li>
                        </ol>
                    </td>
                </tr>
            </table>
        </details>
    </li>
    <li><code>extend_protfin_out.awk</code> - A script to extend the protfin output with two columns for the match related mapman bins</li>
    <li><code>raincloud_plot.R</code> - A script to plot groups of values into a raincloud plot</li>
    <li><code>summary.py</code> - A script to summarize the output of <code>evaluation.py eval</code></li>
</ul>

---
## Results (`results/*`)
|                          file                            |     content
|----------------------------------------------------------|------------------
|[test_selection.summary.csv](./results/test_selection.summary.csv)|a summary of the found matches for 217 protein sequences (7 per family)
|[summary.csv](./results/summary.csv)|a summary of the `*.summary.csv` files
|[hash_count_dist.png](./results/hash_count_dist.png)|a raincloud plot of the hash counts calculated for the sequences
|[frequencies.png](./results/frequencies.png)|A scatter plot of the frequences that are included in constellation maps
|[matches.png](./results/matches.png)|A scattered box plot of the found matches per protein, with focus on family relatives
|[prots_per_hash.png](./results/prots_per_hash.png)|A raincloud plot of the protein counts that share the same hash
|[prots_per_windist.png](./results/prots_per_windist.png)|A boxplot of the protein counts per hash, grouped by the hash's window distance

### Reproduce
In this repository, `protein.fa` is used to generate the database. You can extract the file from [this archive](https://github.com/usadellab/prot-fin/raw/5be77c4247327e3958c89200c03a938ec4734834/material/Mapman_reference_DB_202310.tar.bz2). The archive also includes `mapmanreferencebins.results.txt` which maps the proteins to their families.

The used table of Kidera factors is located in [../../materials/Amino_Acid_Kidera_Factors.csv](../../materials/Amino_Acid_Kidera_Factors.csv) and was generated by [this R-script](https://github.com/usadellab/prot-fin/blob/5be77c4247327e3958c89200c03a938ec4734834/methods/Amino_Acid_Kidera_Factors.R). (Read the [root-README](../../README.md) for more details).

[test_selection.summary.csv](./results/test_selection.summary.csv):
```sh
cd methods
materials=../../../materials
python3 protfin.py create-db -c 6 $materials/protein.fa
python3 evaluation.py select-samples $materials/mapmanreferencebins.results.txt $materials/protein.fa -s 7 > ../results/_test_selection.fa
python3 protfin.py find-matches ../results/_test_selection.fa > ../results/_test_selection.matches
python3 evaluation.py eval ../results/_test_selection.matches > ../results/test_selection.summary.csv
```

[summary.csv](./results/summary.csv):
```sh
cd methods
python3 summary.py ../results/*.summary.csv > ../results/summary.csv
```

[hash_count_dist.png](./results/hash_count_dist.png):
```sh
cd methods
materials=../../../materials
python3 protfin.py create-db -c 6 $materials/protein.fa
TITLE="Distribution of sequences' hash counts" X_LABEL="Hash counts" \
Rscript raincloud_plot.R normal <(python3 evaluation.py print-hash-counts database.pickle) ../results/hash_count_dist.png
```

[frequencies.png](./results/frequencies.png):
```sh
cd methods
materials=../../../materials
python3 evaluation.py plot-frequencies -c 6 $materials/protein.fa ../results/frequencies.png
```

[matches.png](./results/matches.png):
```sh
cd methods
materials=../../../materials
python3 protfin.py create-db -c 6 $materials/protein.fa
python3 evaluation.py select-samples $materials/mapmanreferencebins.results.txt $materials/protein.fa -s 7 > ../results/_test_selection.fa
python3 protfin.py find-matches ../results/_test_selection.fa > ../results/_test_selection.matches
awk -v protfin_out=../results/_test_selection.matches -f extend_protfin_out.awk ../../../materials/mapmanreferencebins.results.txt > ../results/_test_selection.matches.extended
python3 evaluation.py plot-extended-out ../results/_test_selection.matches.extended ../results/matches.png
```

[prots_per_hash.png](./results/prots_per_hash.png):
```sh
cd methods
materials=../../../materials
python3 protfin.py create-db -c 6 $materials/protein.fa
TITLE="Distribution of proteins per hash" X_LABEL="Protein counts" \
Rscript raincloud_plot_log10.R normal <(python3 evaluation.py print-prots-per-hash database.pickle) ../results/prots_per_hash.png
```

[prots_per_windist.png](./results/prots_per_windist.png):
```sh
cd methods
materials=../../../materials
python3 protfin.py create-db -c 6 $materials/protein.fa
python3 evaluation.py plot-prots-per-windist database.pickle ../results/prots_per_windist.png
```

---
## Discussion/Brainstorming
As of <code>summary.csv</code>, the original match is mostly found. Looking into <code>test_selection.summary.csv</code> and <code>protein.fa</code>, the matches with multiple first hits have just other proteins with duplicate sequences in <code>protein.fa</code>.
So it is actually always found.

The plot of the matches in <code>matches.png</code> indicates that there is no real difference in scoring between family related and non-related proteins for an input sequence. There are some sequences with higher scores, but these are just some with high sequence similarity when inspecting the <code>protein.fa</code>.

Some ideas for future development:
 - add appropriate testing
 - find ways to create more qualitative hashes:
   - find the best combination of parameters for the STFT
   - don't just use the peaks only (`create_constellations`)
   - include the frequencies' amplitudes of the STFT in the hashes (maybe 1 Bit if amplitude of frequency A is lower than from B)
 - improve performance/efficiency

---
## Environment

System: `Ubuntu 20.04.6 LTS`
Shell: `zsh 5.8`

| dependency | version |
|------------|---------|
|   python3  | 3.8.10  |
|    scipy   | 1.10.1  |
|    numpy   | 1.23.0  |
|   pandas   |  2.0.1  |
|    tqdm    | 4.66.2  |
| matplotlib |  3.5.2  |
|            |         |
|      R     |  3.6.3  |
|   tibble   |  3.2.1  |
|   ggplot2  |  3.5.0  |
|   ggdist   |  3.3.2  |
|   dplyr    |  1.1.4  |
