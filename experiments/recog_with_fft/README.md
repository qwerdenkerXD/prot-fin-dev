# Recognition with Fast Fourier Transformation <br> v0.3-exp-stft_params
`NOTE: This README and the code are updated synchronously.`

The purpose of this experiment on `prot-fin v0.3`  is to figure out which parameter values are the best for the STFT.<br>
Here are gonna be tested:
 - Window Size
 - Overlap between Windows
 - Number of maximum selected peaks per Window

---

## Usage
1. go to `./methods`
2. create a database of reference proteins: `python3 protfin.py create-db <ref-fasta>`
3. find best scored matches for protein sequence samples: `python3 protfin.py find-matches <samples-fasta>`

### Tools
```sh
cd methods

# start the slurm jobs
bash slurm.sh protein.fa mapmanreferencebins.results.txt

# select sample proteins from different mapman bins
python3 evaluation.py select-samples mapmanreferencebins.results.txt protein.fa > samples.fa

# summarize the *.summary.csv
python3 summary.py *.summary.csv

# extend the protfin output with two columns for the match related mapman bins
awk -v protfin_out=protfin_out.csv -f extend_protfin_out.awk mapmanreferencebins.results.txt > protfin_out.extended.csv

# summarize extende output
python3 evaluation.py eval protfin_out.extended.csv

# create a plot of the extended output file
python3 evaluation.py plot-extended-out protfin_out.extended.csv plot.png

# generate a plot for counts of calculated hashes
TITLE="Distribution of sequences' hash counts" X_LABEL="Hash counts" \
Rscript raincloud_plot.R normal <(python3 evaluation.py print-hash-counts database.pickle) plot.png

# generate a plot for counts of proteins per hash with a log10 transformation
TITLE="Distribution of proteins per hash" X_LABEL="Protein counts" \
Rscript raincloud_plot_log10.R normal <(python3 evaluation.py print-prots-per-hash database.pickle) plot.png
```

### Unit Testing
To run the unit tests, just run the following:
```sh
cd methods
TQDM_DISABLE=1 python3 test.py
```

## Methods (`methods/*`)
<ul>
    <li>
        <details>
            <summary><code>protfin.py</code> - The tool that is going to be developed</summary>
            <table>
                <th>method</th><th>steps</th>
                <tr>
                    <td>actions.algorithm.kidera:<br><code>get_aa_vector(seq, factor, normalize, file)</code></td>
                    <td>
                        <ul><li>defaults: <code>normalize=True</code>, <code>file="../../../materials/Amino_Acid_Kidera_Factors.csv"</code></li></ul>
                        <ol type="1">
                            <li>read kidera factor values for all amino acids from <code>file</code></li>
                            <li>normalize values by adding the global table mean if <code>normalize</code> is <code>True</code></li>
                            <li>extend value table with columns for symbols representing multiple amino acids, by forming the mean of the corresponding amino acids' vectors</li>
                            <li>extend value table with columns for non-valued amino acids 'O' and 'U', by treating their value as zero</li>
                        </ol>
                    </td>
                </tr>
                <tr>
                    <td>actions.algorithm.constellation:<br><code>create_constellation(aa_vec, window_size, n_peaks, window, **kwargs)</code></td>
                    <td>
                        <ul><li>defaults: <code>n_peaks=0</code>, <code>window="boxcar"</code>, <code>overlap@kwargs=window_size//2</code></li></ul>
                        <ol type="1">
                            <li>Initialize values: equalize <code>window_size</code> to <code>aa_vec</code> if it is greater than the vector size, also set <code>overlap=window_size-1</code> if it is bigger than window size</li>
                            <li>If input sequence is shorter than window size, return empty map</li>
                            <li>Do a STFT on <code>aa_vec</code> with the given parameters</li>
                            <li>for each STF-transformed window, get the n most prominent peaks as set by <code>n_peaks</code> or select all if <code>n_peaks=0</code></li>
                            <li>append all tuples of peak and its amplitude as selected by <code>find_peaks</code> as one whole tuple to the constellation map, so one tuple per window with all its frequencies</li>
                        </ol>
                    </td>
                </tr>
                <tr>
                    <td>actions.algorithm.hash_gen:<br><code>create_hashes(constellation_map, prot_id)</code></td>
                    <td>
                        <ol type="1">
                            <li>
                                for each frequency in each window in the map create combinatorial hashes (anker points) with all upcoming frequencies in the next 2<sup>12</sup> windows:<br>
                                as frequencies use a max. of 5 bits each, the hashes are generated by combining them into a 32-bit int like: <br>
                                <code>(zeros)-(index_diff)-(freq_of_other_pair)-(frequency)</code><br>
                                So currently there are 10 unused bits of zeros that can be assigned in further experiments.
                            </li>
                            <li>save index and protein id for each hash</li>
                        </ol>
                    </td>
                </tr>
                <tr>
                    <td>actions.find_matches:<br><code>score_prots(hashes, database, protein_lookup)</code></td>
                    <td>
                        <ol type="1">
                            <li>for each hash, collect for each protein its offsets to its occurences in the protein sequence</li>
                            <li>for each protein, calculate its Jaccard Similarity Index (JSI)</li>
                            <li>the offset having the most matching occurences and the JSI form the score for a protein, as it is the best fitting constellation of the hashes</li>
                            <li>return the scores as Dictionary of protein identifiers pointing to their scores</li>
                        </ol>
                    </td>
                </tr>
                <tr>
                    <td>actions.create_db:<br><code>create_db(prot_file, db_out)</code></td>
                    <td>
                        <ol type="1">
                            <li>create a database for all proteins in the file by joining the results of <code>create_hashes</code></li>
                            <li>create a protein-lookup as well to get to the hash count for each protein</li>
                            <li>dump both into <code>db_out</code></li>
                        </ol>
                    </td>
                </tr>
                <tr>
                    <td>actions.find_matches:<br><code>find_matches(fasta_file, db_in)</code></td>
                    <td>
                        <ol type="1">
                            <li>for each protein in the file, find all match(es), using the database in <code>db_in</code>, and print them to stdout. The score consists of the custom score multiplied with the JSI</li>
                        </ol>
                    </td>
                </tr>
            </table>
            <h3>Convenience</h3>
            <code>actions.algorithm.hashes_from_seq(seq, prot_id)</code>
            <ul>
                <li>just the workflow <code>seq_to_vectors</code> $\rightarrow$ <code>create_constellation</code> $\rightarrow$ <code>create_hashes</code></li>
            </ul>
            <code>tools.Fasta(fasta_file)</code>
            <ul>
                <li>a class to iterate easily through the fasta file's contents with support of slicing, adding also a progress bar to indicate processed proteins</li>
                <li>currently not validating the file</li>
            </ul>
            <code>tools.count_appearances_in_file(pattern, file)</code>
            <ul>
                <li>used to count fastly e.g. the number of proteins in a file, which is necessary to create an appropriate progress bar</li>
            </ul>
            <code>tools.verify_type(val, ty)</code>
            <ul>
                <li>used in unit tests to easily and deeply verify a value's data type</li>
            </ul>
            <code>tools.divide_evenly(num, n_parts)</code>
            <ul>
                <li>currently used to easily divide <code>num</code> tasks equally among assigned cores</li>
            </ul>
            <code>tools.pd_read_chunkwise(csv_file, chunksize)</code>
            <ul>
                <li>used for chunkwise iteration over the protfin output csv to reduce memory usage</li>
                <li>a returned item stores all matches of one input protein</li>
            </ul>
        </details>
    </li>
    <li>
        <details>
            <summary><code>evaluation.py</code> - Test prot-fin with training data and evaluate the results</summary>
            <table>
                <th>method</th><th>steps</th>
                <tr>
                    <td><code>evaluate_protfin(protfin_out_file)</code></td>
                    <td>
                        <ol type="1">
                            <li>for each output in <code>protfin_out_file</code>, extract the matches' data and count them</li>
                            <li>collect the input specific data from below the output</li>
                            <li>store everything into a dataframe and write it as csv to stdout</li>
                        </ol>
                    </td>
                </tr>
                <tr>
                    <td><code>select_samples(mapman, protein_file, samples_per_family)</code></td>
                    <td>
                        <ol type="1">
                            <li>identify the protein families in <code>mapman</code> file</li>
                            <li>for each family, select randomly <code>samples_per_family</code> proteins</li>
                            <li>find the selected proteins in <code>protein_file</code> and write them as new FASTA formatted output to stdout</li>
                        </ol>
                    </td>
                </tr>
                <tr>
                    <td><code>print_hash_counts(database)</code></td>
                    <td>
                        <ol type="1">
                            <li>Extract the hash counts from the protein lookup in <code>database</code></li>
                            <li>Print the extracted values comma separated to stdout</li>
                        </ol>
                    </td>
                </tr>
                <tr>
                    <td><code>print_prots_per_hash(database)</code></td>
                    <td>
                        <ol type="1">
                            <li>Extract the counts of proteins per hash from the <code>database</code></li>
                            <li>Print the extracted values comma separated to stdout</li>
                        </ol>
                    </td>
                </tr>
                <tr>
                    <td><code>plot_frequencies(prot_file, out_file, cpu_count)</code></td>
                    <td>
                        <ol type="1">
                            <li>Create the constellation maps of all sequences and collect the selected frequencies</li>
                            <li>Plot the frequences' rates and indicate how many sequences share a frequence</li>
                        </ol>
                    </td>
                </tr>
                <tr>
                    <td><code>plot_extended_out(ext_out, plot_out)</code></td>
                    <td>
                        <ol type="1">
                            <li>Iterate through the proteins' matches and plot a box of the scores of each</li>
                            <li>Also add dots for each score of family and non-family matches</li>
                        </ol>
                    </td>
                </tr>
            </table>
        </details>
    </li>
    <li><code>extend_protfin_out.awk</code> - A script to extend the protfin output with two columns for the match related mapman bins</li>
    <li><code>raincloud_plot.R</code> - A script to plot groups of values into a raincloud plot</li>
    <li><code>summary.py</code> - A script to summarize the output of <code>evaluation.py eval</code></li>
    <li><code>slurm.sh</code> - A bash script to start the slurm jobs for the different parameters</li>
</ul>

---
## Results (`results/*`)
|                          file                            |     content
|----------------------------------------------------------|------------------
|[test_selection.summary.csv](./results/test_selection.summary.csv)|a summary of the found matches for 217 protein sequences (7 per family)
|[summary.csv](./results/summary.csv)|a summary of the `*.summary.csv` files
|[hash_count_dist.png](./results/hash_count_dist.png)|a raincloud plot of the hash counts calculated for the sequences
|[frequencies.png](./results/frequencies.png)|A scatter plot of the frequences that are included in constellation maps
|[matches.png](./results/matches.png)|A scattered box plot of the found matches per protein, with focus on family relatives
|[prots_per_hash.png](./results/prots_per_hash.png)|A raincloud plot of the protein counts that share the same hash

### Reproduce
In this repository, `protein.fa` is used to generate the database. You can extract the file from [this archive](https://github.com/usadellab/prot-fin/raw/5be77c4247327e3958c89200c03a938ec4734834/material/Mapman_reference_DB_202310.tar.bz2). The archive also includes `mapmanreferencebins.results.txt` which maps the proteins to their families.

The used table of Kidera factors is located in [../../materials/Amino_Acid_Kidera_Factors.csv](../../materials/Amino_Acid_Kidera_Factors.csv) and was generated by [this R-script](https://github.com/usadellab/prot-fin/blob/5be77c4247327e3958c89200c03a938ec4734834/methods/Amino_Acid_Kidera_Factors.R). (Read the [root-README](../../README.md) for more details).

[test_selection.summary.csv](./results/test_selection.summary.csv):
```sh
cd methods
materials=../../../materials
python3 protfin.py create-db -c 6 $materials/protein.fa
python3 evaluation.py select-samples $materials/mapmanreferencebins.results.txt $materials/protein.fa -s 7 > ../results/_test_selection.fa
python3 protfin.py find-matches ../results/_test_selection.fa > ../results/_test_selection.matches
awk -v protfin_out=../results/_test_selection.matches -f extend_protfin_out.awk ../../../materials/mapmanreferencebins.results.txt > ../results/_test_selection.matches.extended
python3 evaluation.py eval ../results/_test_selection.matches.extended > ../results/test_selection.summary.csv
```

[summary.csv](./results/summary.csv):
```sh
cd methods
python3 summary.py ../results/*.summary.csv > ../results/summary.csv
```

[hash_count_dist.png](./results/hash_count_dist.png):
```sh
cd methods
materials=../../../materials
python3 protfin.py create-db -c 6 $materials/protein.fa
TITLE="Distribution of sequences' hash counts" X_LABEL="Hash counts" \
Rscript raincloud_plot.R normal <(python3 evaluation.py print-hash-counts database.pickle) ../results/hash_count_dist.png
```

[frequencies.png](./results/frequencies.png):
```sh
cd methods
materials=../../../materials
python3 evaluation.py plot-frequencies -c 6 $materials/protein.fa ../results/frequencies.png
```

[matches.png](./results/matches.png):
```sh
cd methods
materials=../../../materials
python3 protfin.py create-db -c 6 $materials/protein.fa
python3 evaluation.py select-samples $materials/mapmanreferencebins.results.txt $materials/protein.fa -s 7 > ../results/_test_selection.fa
python3 protfin.py find-matches ../results/_test_selection.fa > ../results/_test_selection.matches
awk -v protfin_out=../results/_test_selection.matches -f extend_protfin_out.awk ../../../materials/mapmanreferencebins.results.txt > ../results/_test_selection.matches.extended
python3 evaluation.py plot-extended-out ../results/_test_selection.matches.extended ../results/matches.png
```

[prots_per_hash.png](./results/prots_per_hash.png):
```sh
cd methods
materials=../../../materials
python3 protfin.py create-db -c 6 $materials/protein.fa
TITLE="Distribution of proteins per hash" X_LABEL="Protein counts" \
Rscript raincloud_plot_log10.R normal <(python3 evaluation.py print-prots-per-hash database.pickle) ../results/prots_per_hash.png
```

---
## Discussion/Brainstorming

Some ideas for future development:
 - add appropriate testing

---
## Environment
<ul>
    <li><b>Personal</b><br>
        System: <code>Ubuntu 20.04.6 LTS</code>
        Shell: <code>zsh 5.8</code><br>
        <br>
        <table>
            <th>dependency</th><th>version</th>
            <tr><td>python3</td><td>3.8.10</td></tr>
            <tr><td>scipy</td><td>1.10.1</td></tr>
            <tr><td>numpy</td><td>1.23.0</td></tr>
            <tr><td>pandas</td><td>2.0.1</td></tr>
            <tr><td>tqdm</td><td>4.66.2</td></tr>
        </table>
    </li>
    <li><b>Slurm</b><br>
        System: <code>Ubuntu 20.04.4 LTS</code>
        Shell: <code>zsh 5.8.1</code><br>
        <br>
        <table>
            <th>dependency</th><th>version</th>
            <tr><td>slurm-wlm</td><td>21.08.5</td></tr>
            <tr><td>python3</td><td>3.10.12</td></tr>
            <tr><td>scipy</td><td>1.11.4</td></tr>
            <tr><td>numpy</td><td>1.26.2</td></tr>
            <tr><td>pandas</td><td>2.1.3</td></tr>
            <tr><td>tqdm</td><td>4.66.2</td></tr>
            <tr><td>matplotlib</td><td>3.8.2</td></tr>
        </table>
    </li>
</ul>
